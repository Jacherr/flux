use crate::core::error::FluxError;
//use crate::framebuffer::FrameBuffer;
use crate::processing::css_framebuffer::quant;
use crate::processing::framebuffer::FrameBuffer;
use crate::util::convert_ratio_to_integer;
use gif::{AnyExtension, Frame};
use image::codecs::gif::Repeat;
use image::{Delay, DynamicImage};
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};
use std::convert::TryInto;

fn convert_image_frame_to_gif_frame<'a>(w: u16, h: u16, delay: Delay, quant: quant::result) -> Frame<'a> {
    let (numer, denom) = delay.numer_denom_ms();

    let mut palette = vec![0u8; 3 * quant.palette.len()];

    for (i, color) in quant.palette.iter().enumerate() {
        palette[i * 3] = color.r;
        palette[i * 3 + 1] = color.g;
        palette[i * 3 + 2] = color.b;
    }

    let frame_delay = convert_ratio_to_integer(numer, denom);
    if palette.len() > 3 {
        palette[3] = palette[0];
        palette[4] = palette[1];
        palette[5] = palette[2];
    }

    let mut frame = Frame::from_palette_pixels(w, h, quant.index, palette, quant.transparency.map(|z| z as u8));

    frame.delay = (frame_delay / 10).try_into().unwrap_or(std::u16::MAX);
    frame.dispose = gif::DisposalMethod::Background;

    frame
}

fn convert_repeat(repeat: Repeat) -> gif::Repeat {
    match repeat {
        Repeat::Finite(a) => gif::Repeat::Finite(a),
        Repeat::Infinite => gif::Repeat::Infinite,
    }
}

pub fn encode(
    frames: Vec<(&DynamicImage, Delay)>,
    width: u16,
    height: u16,
    repeat: Repeat,
) -> Result<Vec<u8>, FluxError> {
    let mut buf: Vec<u8> = vec![];

    if frames.is_empty() {
        return Ok(buf);
    };

    let mut encoder = gif::Encoder::new(&mut buf, width, height, &[]).map_err(|e| FluxError::Other(e.to_string()))?;

    encoder
        .set_repeat(convert_repeat(repeat))
        .map_err(|e| FluxError::Other(e.to_string()))?;

    let new_frames: Vec<gif::Frame> = frames
        .par_iter()
        .map(|x| {
            let fb = FrameBuffer::new_from_dyn_image(x.0);

            let quant = quant::quantize(
                &fb,
                &quant::options {
                    fast: false,
                    ..Default::default()
                },
            );

            convert_image_frame_to_gif_frame(x.0.width() as _, x.0.height() as _, x.1, quant)
        })
        .collect::<Vec<_>>();

    for frame in new_frames {
        encoder
            .write_frame(&frame)
            .map_err(|e| FluxError::Other(e.to_string()))?;
    }

    encoder
        .write_raw_extension(
            AnyExtension(0xFE),
            &["Generated by Assyst WSI (jacher.io/assyst)".as_bytes()],
        )
        .map_err(|e| FluxError::Other(e.to_string()))?;

    drop(encoder);

    Ok(buf)
}
